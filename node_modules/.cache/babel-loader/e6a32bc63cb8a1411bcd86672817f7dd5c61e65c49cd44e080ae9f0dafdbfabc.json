{"ast":null,"code":"import \"core-js/modules/es.object.define-property.js\";\n// Utilities\nimport { computed, ref, watch } from 'vue';\nimport { getCurrentInstance, toKebabCase } from \"../util/index.mjs\";\nimport { useToggleScope } from \"./toggleScope.mjs\"; // Types\n// Composables\nexport function useProxiedModel(props, prop, defaultValue) {\n  var transformIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (v) {\n    return v;\n  };\n  var transformOut = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (v) {\n    return v;\n  };\n  var vm = getCurrentInstance('useProxiedModel');\n  var internal = ref(props[prop] !== undefined ? props[prop] : defaultValue);\n  var kebabProp = toKebabCase(prop);\n  var checkKebab = kebabProp !== prop;\n  var isControlled = checkKebab ? computed(function () {\n    var _vm$vnode$props, _vm$vnode$props2, _vm$vnode$props3, _vm$vnode$props4;\n    void props[prop];\n    return !!(((_vm$vnode$props = vm.vnode.props) != null && _vm$vnode$props.hasOwnProperty(prop) || (_vm$vnode$props2 = vm.vnode.props) != null && _vm$vnode$props2.hasOwnProperty(kebabProp)) && ((_vm$vnode$props3 = vm.vnode.props) != null && _vm$vnode$props3.hasOwnProperty(\"onUpdate:\".concat(prop)) || (_vm$vnode$props4 = vm.vnode.props) != null && _vm$vnode$props4.hasOwnProperty(\"onUpdate:\".concat(kebabProp))));\n  }) : computed(function () {\n    var _vm$vnode$props5, _vm$vnode$props6;\n    void props[prop];\n    return !!((_vm$vnode$props5 = vm.vnode.props) != null && _vm$vnode$props5.hasOwnProperty(prop) && (_vm$vnode$props6 = vm.vnode.props) != null && _vm$vnode$props6.hasOwnProperty(\"onUpdate:\".concat(prop)));\n  });\n  useToggleScope(function () {\n    return !isControlled.value;\n  }, function () {\n    watch(function () {\n      return props[prop];\n    }, function (val) {\n      internal.value = val;\n    });\n  });\n  var model = computed({\n    get: function get() {\n      return transformIn(isControlled.value ? props[prop] : internal.value);\n    },\n    set: function set(value) {\n      var newValue = transformOut(value);\n      if ((isControlled.value ? props[prop] : internal.value) === newValue || transformIn(isControlled.value ? props[prop] : internal.value) === value) {\n        return;\n      }\n      internal.value = newValue;\n      vm == null ? void 0 : vm.emit(\"update:\".concat(prop), newValue);\n    }\n  });\n  Object.defineProperty(model, 'externalValue', {\n    get: function get() {\n      return isControlled.value ? props[prop] : internal.value;\n    }\n  });\n  return model;\n}","map":{"version":3,"names":["computed","ref","watch","getCurrentInstance","toKebabCase","useToggleScope","useProxiedModel","props","prop","defaultValue","transformIn","arguments","length","undefined","v","transformOut","vm","internal","kebabProp","checkKebab","isControlled","_vm$vnode$props","_vm$vnode$props2","_vm$vnode$props3","_vm$vnode$props4","vnode","hasOwnProperty","concat","_vm$vnode$props5","_vm$vnode$props6","value","val","model","get","set","newValue","emit","Object","defineProperty"],"sources":["../../src/composables/proxiedModel.ts"],"sourcesContent":["// Utilities\nimport { computed, ref, watch } from 'vue'\nimport { getCurrentInstance, toKebabCase } from '@/util'\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Types\nimport type { Ref } from 'vue'\n\ntype InnerVal<T> = T extends any[] ? Readonly<T> : T\n\n// Composables\nexport function useProxiedModel<\n  Props extends object & { [key in Prop as `onUpdate:${Prop}`]: ((val: any) => void) | undefined },\n  Prop extends Extract<keyof Props, string>,\n  Inner = Props[Prop],\n> (\n  props: Props,\n  prop: Prop,\n  defaultValue?: Props[Prop],\n  transformIn: (value?: Props[Prop]) => Inner = (v: any) => v,\n  transformOut: (value: Inner) => Props[Prop] = (v: any) => v,\n) {\n  const vm = getCurrentInstance('useProxiedModel')\n  const internal = ref(props[prop] !== undefined ? props[prop] : defaultValue) as Ref<Props[Prop]>\n  const kebabProp = toKebabCase(prop)\n  const checkKebab = kebabProp !== prop\n\n  const isControlled = checkKebab\n    ? computed(() => {\n      void props[prop]\n      return !!(\n        (vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) &&\n        (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`))\n      )\n    })\n    : computed(() => {\n      void props[prop]\n      return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`))\n    })\n\n  useToggleScope(() => !isControlled.value, () => {\n    watch(() => props[prop], val => {\n      internal.value = val\n    })\n  })\n\n  const model = computed({\n    get (): any {\n      return transformIn(isControlled.value ? props[prop] : internal.value)\n    },\n    set (value) {\n      const newValue = transformOut(value)\n      if (\n        (isControlled.value ? props[prop] : internal.value) === newValue ||\n        transformIn(isControlled.value ? props[prop] : internal.value) === value\n      ) {\n        return\n      }\n      internal.value = newValue\n      vm?.emit(`update:${prop}`, newValue)\n    },\n  }) as any as Ref<InnerVal<Inner>> & { readonly externalValue: Props[Prop] }\n\n  Object.defineProperty(model, 'externalValue', {\n    get: () => isControlled.value ? props[prop] : internal.value,\n  })\n\n  return model\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}